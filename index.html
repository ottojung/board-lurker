
 <!-- Copyright (C) 2022  Otto Jung -->

 <!-- This program is free software: you can redistribute it and/or modify -->
 <!-- it under the terms of the GNU General Public License as published by -->
 <!-- the Free Software Foundation; version 3 of the License. -->

 <!-- This program is distributed in the hope that it will be useful, -->
 <!-- but WITHOUT ANY WARRANTY; without even the implied warranty of -->
 <!-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the -->
 <!-- GNU General Public License for more details. -->

 <!-- You should have received a copy of the GNU General Public License -->
 <!-- along with this program.  If not, see <http://www.gnu.org/licenses/>. -->

<head>
  <meta charset="utf-8">
  <meta name="robots" content="noarchive">
  <meta name="description" content="NEW SOCIALS - &quot;/b/ - Random&quot; is the birthplace of Anonymous, and where people go to discuss random topics and create memes on 4chan.">
  <meta name="keywords" content="imageboard,anonymous,random,memes,SOCIALS">
  <meta name="referrer" content="origin">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link rel="shortcut icon" href="https://s.4cdn.org/image/favicon.ico" type="image/x-icon">
  <link rel="stylesheet" title="switch" href="ass/yotsubanew.704.css">
  <link rel="alternate stylesheet" style="text/css" href="ass/yotsubanew.704.css" title="Yotsuba New">
  <link rel="alternate stylesheet" style="text/css" href="ass/yotsubluenew.704.css" title="Yotsuba B New">
  <link rel="alternate stylesheet" style="text/css" href="ass/futabanew.704.css" title="Futaba New">
  <link rel="alternate stylesheet" style="text/css" href="ass/burichannew.704.css" title="Burichan New">
  <link rel="alternate stylesheet" style="text/css" href="ass/photon.704.css" title="Photon">
  <link rel="alternate stylesheet" style="text/css" href="ass/tomorrow.704.css" title="Tomorrow">
  <link rel="stylesheet" href="ass/yotsubamobile.704.css">
  <link rel="alternate" title="RSS feed" href="/b/index.rss" type="application/rss+xml">
  <title>4chan viewer</title>

  <script>

    const thread_statistics = {};
    const statistics_span = 1000;

    function statistics_get(board) {
        const existing = thread_statistics[board];
        if (!existing) {
            var max = 0;
            var ring = [];
            var index = 0;
            var stat = { ring, max, index };
            thread_statistics[board] = stat;
            return stat;
        } else {
            return existing;
        }
    }

    function append_statistics(thread) {
        const stat = statistics_get(thread.board);
        stat.ring[stat.index] = thread;
        stat.index = (stat.index + 1) % statistics_span;
    }

    function update_statistics(board) {
        const stat = statistics_get(board);
        stat.max = stat.ring.reduce((acc, cur) => Math.max(acc, cur.replies), 0);
    }

    async function get_threads(board) {
        var response = await fetch("https://a.4cdn.org/" + board + "/catalog.json");
        var json = await response.json();

        var joined = [];

        for (var i = 0; i < json.length; i++) {
            var threads = json[i].threads;
            for (var k = 0; k < threads.length; k++) {
                var thread = threads[k];
                thread.board = board;
                joined.push(thread);
            }
        }

        return joined;
    }

    async function get_thread_posts(board, thread_id) {
        try {
            var response = await fetch("https://a.4cdn.org/" + board + "/thread/" + thread_id.toString() + ".json");
            if (response.status === 404) {
                all_threads[thread_id].deleted = true;
                return null;
            }

            var json = await response.json();
            return json.posts;
        } catch (ex) {
            console.log({"error": true, thread_id, ex});
            return null;
        }
    }

    function make_posts_map(posts) {
        var ret = {};
        if (!posts) { return ret; }

        for (var i = 0; i < posts.length; i++) {
            var post = posts[i];
            post.my_index = i;
            post.my_replies_count = 0;
            ret[post.no] = post;
        }

        return ret;
    }

    var thread_div = null;
    function get_thread_div() {
        if (thread_div == null) {
            thread_div = document.getElementsByClassName("thread")[0];
        }
        return thread_div;
    }

    function get_backup_post_link(board, thread_id, post_id) {
        switch (board) {
        case "b":
        case "bant":
            return `https://thebarchive.com/${board.toString()}/thread/${thread_id.toString()}/#p${post_id.toString()}"`;
        case "pol":
        case "adv":
        case "f":
        case "hr":
        case "o":
        case "pol":
        case "s4s":
        case "sp":
        case "tg":
        case "trv":
        case "tv":
        case "x":
            return `https://4plebs.org/${board.toString()}/thread/${thread_id.toString()}/#p${post_id.toString()}"`;
        default:
            return `https://archived.moe/${board.toString()}/thread/${thread_id.toString()}/#p${post_id.toString()}"`;
        }
    }

    function get_post_link(board, thread_id, post_id) {
        return `https://boards.4chan.org/${board.toString()}/thread/${thread_id.toString()}/#p${post_id.toString()}"`;
    }

    var display_buffer = [];

    function append_html_to_thread_div(html) {
        display_buffer.push(html);
    }

    function append_delimiter_to_thread_div() {
        append_html_to_thread_div("</br><hr></br>");
    }

    function unixtime_to_string(unixtime) {
        var d = new Date(unixtime * 1000);
        var dateStr = `${('0' + d.getDate()).slice(-2)} ${d.getHours()}:${('0' + d.getMinutes()).slice(-2)}:${('0' + d.getSeconds()).slice(-2)}`;
        return dateStr;
    }

    function delete_thread(thread_id) {
        var thread = all_threads[thread_id];
        thread.deleted = true;
        thread.posts_obj = null;
    }

    function delete_button_click(thread_id) {
        delete_thread(thread_id);
        redraw();
    }

    function display_post(op_q, board, thread_id, post) {
        var link = get_post_link(board, thread_id, post.no);
        var now = unixtime_to_string(post.time);
        var comment = post.com ? post.com.toString() : '';
        var subject = post.sub ? `<span class="subject">${post.sub.toString()}</span>` : '';
        var deleteButton = op_q ? `<input type="button" id=${thread_id} value="delete" onclick="delete_button_click(${thread_id})"/>` : '';
        var boardTag = op_q ? `<b style='color:blue'> /${board}/ </b>` : '';
        var replies_count = op_q ? post.replies : post.my_replies_count;
        var replyCount = replies_count ? `<span class="nameBlock"> (${replies_count}) </span>` : '';
        var file = post.filename ? `
<div class="file">
  <div class="fileText">
     File: <a href="https://i.4cdn.org/${board}/${post.tim}${post.ext}" target="_blank">${post.filename}${post.ext}</a>
  </div>
  <a class="fileThumb" href="https://i.4cdn.org/${board}/${post.tim}${post.ext}" target="_blank">
    <img src="https://i.4cdn.org/${board}/${post.tim}s.jpg" alt="" data-md5="" style="" loading="lazy">
  </a>
</div>` : '';

        append_html_to_thread_div(`
<div class="postContainer ${op_q ? 'opContainter' : 'replyContainer'}">
  <div class="sideArrows"></div>
    <div class="post ${op_q ? 'op' : 'reply'}">
      <div class="postInfo desktop">
        ${deleteButton}
        ${boardTag}
        ${subject}
        ${replyCount}
        <span class="nameBlock">
          <span class="name"> ${post.name} </span>
        </span>
        <span class="dateTime">${now}</span>
        <span class="postNum desktop">
          <a href="${link}" title="Link to this post" target="_blank" rel="noopener noreferrer">No.</a>
          <!-- <a href="javascript:quote('${post.no.toString()}');">${post.no.toString()}</a> -->
        </span>
      </div>
      ${file}
      <div> ${comment} </div>
    </div>
  </div>
</div>`);
    }

    function display_op_post(thread) {
        display_post(true, thread.board, thread.no, thread);
    }

    function display_reply_post(board, thread_id, post) {
        display_post(false, board, thread_id, post);
    }

    var responses_regex = /a href="#p(\d+)/g;

    function rank_posts_map(obj) {
        for (const [key, value] of Object.entries(obj)) {
            var comment = value.com;
            if (comment) {
                var match = comment.matchAll(responses_regex);
                for (const m of match) {
                    const to = m[1];
                    obj[to].my_replies_count += 1;
                }
            }
        }
    }

    function relink_post(thread, post) {
        function relinker(match, p1, offset, string) {
            // how this works: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace
            var link = get_post_link(thread.board, thread.no, p1);
            return `a target="_blank" rel="noopener noreferrer" href="${link}"`;
        }

        var comment = post.com;
        if (comment) {
            post.com = comment.replace(responses_regex, relinker);
        }
    }

    function relink_posts(thread, posts) {
        for (const post of posts) {
            relink_post(thread, post);
        }
    }

    function rank_posts(posts_obj) {
        if (!posts_obj.map) {
            posts_obj.map = make_posts_map(posts_obj.list);
            rank_posts_map(posts_obj.map);
        }
    }

    function compare_numbers(a, b) {
        if (a === b) { return 0; }
        if (b === undefined) { return -1; }
        if (a === undefined) { return 1; }
        if (a < b) { return 1; }
        return -1;
    }

    var replies_to_display = 5;

    function display_posts(board, thread, posts) {
        if (!posts) { return; }
        var op_no = thread.no;
        var sorted = posts.sort((a, b) => compare_numbers(a.my_replies_count, b.my_replies_count));
        var k = replies_to_display;
        for (var i = 0; i < posts.length; i++) {
            var post = posts[i];
            if (post.no !== op_no) {
                display_reply_post(board, thread.no, post);
                if ((--k) == 0) { break; }
            }
        }
    }

    function display_thread(board, thread) {
        rank_posts(thread.posts_obj);
        relink_posts(thread, thread.posts_obj.list);
        display_op_post(thread);
        display_posts(board, thread, thread.posts_obj.list);
        append_delimiter_to_thread_div();
    }

    function finalize_display() {
        var div = get_thread_div();
        var html = display_buffer.join('\n');
        div.innerHTML = html;
        display_buffer = [];
    }

    async function reload_thread_posts(thread) {
        var list = await get_thread_posts(thread.board, thread.no);
        thread.posts_obj = { list };
    }

    async function load_thread_posts(thread) {
        if (!thread.posts_obj) {
            await reload_thread_posts(thread);
        }
        return thread;
    }

    var all_threads = {};
    var filter_input = null;
    var init_filter_regex = null;
    const default_boards = ["pol", "b", "bant", "t", "g", "sci", "lit", "b", "h", "cm"];
    var boards_map = {};

    function init_boards_map(board_string) {
        const list = board_string.split(' ');
        boards_map = {};
        for (const board of list) {
            boards_map[board] = true;
        }
    }

    function on_input_enter(name, fun) {
        const input = document.getElementById(name);
        input.addEventListener("keyup", function(event) {
            if (event.keyCode === 13) {
                event.preventDefault();
                fun(input);
            }
        });
        return input;
    }

    function init_filter() {
        on_input_enter("my_filter", function(input) {
            var text = input.value;
            if (text) {
                init_filter_regex = new RegExp(text, "i");
            } else {
                init_filter_regex = null;
            }

            refilter_and_redraw();
        });
    }

    function init_boards_list_element() {
        function hook(input) {
            if (!input.value) {
                input.value = default_boards.join(' ');
            }

            init_boards_map(input.value);
            main_loop();
        }

        const input = on_input_enter("my_boards_list", hook);
        hook(input);
    }

    const min_replies_for_filter = 10;

    async function is_positively_filtered(thread) {
        if (thread.replies < min_replies_for_filter) { return false; }
        if (!init_filter_regex) { return false; }

        var sub = thread.sub ? thread.sub : '';
        var com = thread.com ? thread.com : '';
        var text = '/' + thread.board + '/' + ' ' + sub + ' ' + com;
        return text.match(init_filter_regex);
    }

    const statistics_threashold = 0.95;

    function has_many_replies_q(thread) {
        const stat = statistics_get(thread.board);
        if (thread.replies > statistics_threashold * stat.max) {
            return true;
        }

        return false;
        // NOTE: obsolete, statistics is used instead.
        switch (thread.board) {
        case "pol":
            return thread.replies > 350;
        case "b":
        case "bant":
        case "adv":
        case "f":
        case "hr":
        case "o":
        case "pol":
        case "s4s":
        case "sp":
        case "tg":
        case "trv":
        case "tv":
        case "x":
        case "t":
        case "g":
        case "sci":
        case "lit":
        case "cm":
            return thread.replies > 290;
        case "h": return false;
        default:
            throw new Error(`Uknown thread board "${thread.board}"`);
        }
    }

    function is_bad_board(thread) {
        return !(boards_map[thread.board]);
    }

    async function ok_thread_q(thread) {
        if (is_bad_board(thread)) {
            return false;
        }

        if (await is_positively_filtered(thread)) {
            await reload_thread_posts(thread);
            return true;
        }

        if (has_many_replies_q(thread)) {
            return true;
        }

        return false;
    }

    var to_redraw_threads = [];

    async function refilter_and_redraw() {
        to_redraw_threads = [];
        for (const [k, thread] of Object.entries(all_threads)) {
            if (thread.deleted) { continue; }
            if (await ok_thread_q(thread)) {
                to_redraw_threads.push(thread);
                await load_thread_posts(thread);
            }
        }

        redraw();
    }

    function redraw() {
        var threads = to_redraw_threads.sort((a, b) => compare_numbers(a.time, b.time));
        for (const thread of threads) {
            if (thread.deleted) { continue; }
            display_thread(thread.board, thread);
        }
        finalize_display();
    }

    async function main_loop() {
        var list = Object.keys(boards_map);
        var poll = list.map(get_threads);
        var current = (await Promise.all(poll)).flat();

        for (const thread of current) {
            const existing = all_threads[thread.no];
            if (!existing) {
                all_threads[thread.no] = thread;
                append_statistics(thread);
            } else {
                for (const [key, value] of Object.entries(thread)) {
                    existing[key] = value;
                }
            }
        }

        list.forEach(update_statistics);

        await refilter_and_redraw();
    }

    function main() {
        main_loop().then(_ => setTimeout(main, 60 * 1000));
    }

    console.log("Start");
    document.addEventListener('DOMContentLoaded', (event) => {
        main();
        init_filter();
        init_boards_list_element();
    });

  </script>
</head>

<body class="is_thread board_b yotsuba_new nws">
  <input id="my_filter" placeholder="Positive filter RegEx here" submit=""/>
  <input id="my_boards_list" placeholder="Boads list" submit=""/>

  <form name="delform" id="delform">
    <div class="board">
      <div class="thread">

      </div>
    </div>
  </form>
</body>
